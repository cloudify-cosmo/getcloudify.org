---
layout: bt_wiki
title: Security Guide
category: Guides
publish: true
abstract: Cloudify's Management security configuration and client usage
pageord: 500

---
{%summary%} {{page.abstract}}{%endsummary%}

# Overview

This guide will explain how to bootstrap a secured manager and use it from the CLI and web UI. <br>
Securing the manager focuses on the REST service, which is the access point of all clients to the management server.

Cloudify's security framework uses the [Flask-secuREST](https://github.com/cloudify-cosmo/flask-securest/tree/0.6)
package, which integrates with [Flask-RESTful](https://flask-restful.readthedocs.org/en/0.3.2/) to secure REST services.

When security is enabled, all requests to the REST service are authenticated using the specified [userstore](https://github.com/cloudify-cosmo/flask-securest/tree/master#userstore) and [authentication provider](https://github.com/cloudify-cosmo/flask-securest/tree/master#authentication-provider) (see [Setting up a secured server](#setting-up-a-secured-server)), before they can reach their endpoint (except internal requests, as explained in the Advanced section below).<br>
For example, when a user of the Web-UI attempts to see the all blueprints, a request is sent to the REST service
"blueprints" endpoint, but it will only reach it if the user is logged in with valid credentials. <br>
Similarly, the CLI command "cfy deployments create" will only be successful if valid
credentials are sent with the REST call to the endpoint "deployments".
Of course, direct requests made using other clients (e.g. curl) must also include correct credentials, or they will
fail with an "Unauthorized User" error.


# Token Generation
Tokens can be used as an authentication method.<br> 
In order to send a token with each request, the user must first receive a token. 
Tokens can be generated by many systems, and they will work as long as the token can be processed by
one of the registered authentication providers.

To make things easier, Cloudify can also generate tokens through the REST service endpoint "/tokens".
To enable this feature a token generator must be configured.

{% note title=Note %}
The request to "/tokens" must itself be authenticated (using a username-password set, for example).
{% endnote %}


# Setting up a secured server

## Manager Blueprint Configuration
The security configuration is located in the manager blueprint, in this path:
{% highlight yaml %}
node_templates
  ...
  manager
    ...
    properties
      ...
      cloudify
        ...
        security
{% endhighlight %}
Each setting is described in detail in the following sections.

### Setting Security On / Off
The first setting in the "security" path is:

{% highlight yaml %}
enabled: false
{% endhighlight %}

This means security is turned off. In order to activate the security framework set `enabled: true`
Otherwise, all other security configuration will be ignored.

### Configuring Authentication Providers
Under `authentication_providers` is a list all the authenticators *In the order they should be executed*.<br>
At least one authentication provider must be configured.

Each authentication provider must include these properties:

- name - a unique name describing this authenticator. This name will appear in logs so it should be clear.
- implementation - the fully qualified name of a module implementing an authentication provider, followed by ":" and
the class name.
- properties - a dictionary of arguments required to instantiate the authentication provider class. The arguments will
be passed as kwargs to the class' `__init__` method.

The default configuration uses two authentication methods - password and token:

{% highlight yaml %}
authentication_providers:
  - name: password
    implementation: flask_securest.authentication_providers.password:PasswordAuthenticator
    properties:
      password_hash: plaintext
  - name: token
    implementation: flask_securest.authentication_providers.token:TokenAuthenticator
    properties:
      secret_key: my_secret
{% endhighlight %}

The above configuration will cause the security framework to instantiate two classes:

- Flask-secuREST's "PasswordAuthenticator", with the `password_hash` argument set to "plaintext".

{%note title=Note%}
Passwords are usually not stored as plaintext. Set `passowrd_hash` to match the hash scheme used
in the selected userstore.
Possible values are: 'bcrypt', 'des_crypt', 'pbkdf2_sha256', 'pbkdf2_sha512', 'sha256_crypt' and 'sha512_crypt'.
{%endnote%}

This authentication check will be performed first for each request sent to the REST service. If it fails, the next
authenticator will be used.

- Flask-secuREST's "TokenAuthenticator", with the `secret_key` argument set to "my_secret".<br>
The secret key is used to decrypt the token sent with the request, if a token was sent.

{%note title=Note%}
  When selecting a token authenticator, it is required to verify it supports the tokens generated by your token generator (which might be implmeneted elsewhere entirely).
{%endnote%}

It is possible to implement many other authentication providers, including providers that do not require accessing a
userstore directly (e.g. oAuth). This is explained later in this document.

### Configuring a Userstore
Under "userstore_driver" a single userstore is set:

- implementation - the fully qualified name of the module implementing a userstore integration, followed by ":" and the
class name.
- properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

The default configuration uses Flask-secuREST's simple userstore, with an in-line list of users:

{% highlight yaml %}
userstore_driver:
  implementation: flask_securest.userstores.simple:SimpleUserstore
  properties:
    userstore:
      user1:
        username: example_user1
        password: example_password1
        email: example_user1@your_domain.dom
      user2:
        username: example_user2
        password: example_password2
        email: example_user2@your_domain.dom
      user3:
        username: example_user3
        password: example_password3
        email: example_user3@your_domain.dom
    identifying_attribute: username
{% endhighlight %}

In the default configuration a userstore is created on the fly, containing the 3 listed users. The identifying
attribute (by which a user can be identified) is set to "username".
This is a very simple implementation useful for demonstration. To integrate with a "real" userstore a different
implementation can be created and installed, as explained later.


### Configuring a Token Generator
In order to enable token generation through the REST "/tokens" endpoint a token generator must be configured:

- implementation - the fully qualified name of the module implementation token generation, followed by ":" and the
class name.
- properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

The default configuration uses Flask-secuREST's token module to generate tokens:

{% highlight yaml %}
auth_token_generator:
  implementation: flask_securest.authentication_providers.token:TokenAuthenticator
  properties:
    secret_key: my_secret
    expires_in_seconds: 600
{% endhighlight %}

{%note title=Note%}
In the default TokenAuthenticator implementation, the key used for token authentication is the same as the key used to
generate it. This means you should set the same `secret_key` here and in `authentication_providers`.
{%endnote%}

The configuration includes the additional argument `expires_in_seconds` which limits the lifetime of a token
to 10 minutes. A token older than 10 minutes will therefore be expired and fail the request (a feature of the default
token generator implementation).


### SSL
It is possible to interact with a manager that is secured by [SSL](http://en.wikipedia.org/wiki/Transport_Layer_Security).

The SSL configuration is located under `ssl`.<br>
This is the default SSL configuration:
  {% highlight yaml %}
  ssl: {
    enabled: false,
    certificate_path: '',
    private_key_path: ''
  }
  {% endhighlight %}
  This means that SSL is turned off, the manager will not be secured by SSL protocol and all requests to it will be made over port 80 using the protocol 'http'.

  To enable an SSL connection set `enabled` to `true` and specify the certificate and key paths:
  {% highlight yaml %}
    ssl: {
      enabled: true,
      certificate_path: path-to-certificate,
      private_key_path: path-to-private-key
    }
  {% endhighlight %}
  This means that the manager will be secured by SSL with the given certificate and key.<br>
  It also means that every request to the manager must be on port 443 using the 'https' protocol 
  and that the certificate will be sent to any client that asks to verify it. 

{%tip title=Using a self-signed certificate%}

  A [self-signed certificate](http://en.wikipedia.org/wiki/Self-signed_certificate) can be used- this is a certificate that is signed by the manager itself, not by a CA (certificate authority)<br>
  In this case, every client that wants to verify the manager's certificate needs to recieve a copy of the certificate file in order to use it for verification (see [Manager's certificate verification](#ssl-cli-configuration) )


  The following command can be used for creating a self-sigend certificate: 
  {% highlight bash %}
    openssl req -x509 -newkey rsa:2048 -keyout key.pem -out certificate.pem -days 365 
  {% endhighlight %}
  For more information see [The openssl req command](https://www.openssl.org/docs/apps/req.html).
{%endtip%}

{%note title=The certificate's CommonName%}
  If certificate verification is expected by clients, the certificate's common name should be consistent with the manager's ip, because the SSL verification process denies certificates where the common name does not match the URL and all requests to the manager will use the manager's ip as the URL.<br>
  If no certificate verification is expected, then the only requirment is to specify paths to valid certificate and key files (with any common name).
{%endnote%}


### Logging
Security operations, such as authentication success or failure and user details, are audited in dedicated log file on
the management container.
The default configuration is:

{% highlight yaml %}
audit_log_file: /var/log/cloudify/rest-security-audit.log
audit_log_level: INFO
log_file_size_MB: 100
log_files_backup_count: 20
{% endhighlight %}

- Modifying the log level will produce less or more elaborate security auditing; The acceptable values are:
CRITICAL, ERROR, WARNING, INFO or DEBUG.
- audit_log_file_size_MB - limits the log file size. By default, the file is limited to 100 MB. When the file reaches
that size, it will be renamed with the extension ".1" and a new log file will be created.
- audit_log_files_backup_count - sets the maximum number of old log files to keep. By default this value is set to 20.
That means that up to 20 old log files can be created, after which the oldest file will be removed.


# Clients

Different clients can be used to send requests to the REST service, and all go through an authentication process.
Here we review what each client requires in order to send a secured request.


## Web UI
Login - with username and password

{%note title=Note%}
This client only supports authentication with username-password.
{%endnote%}

{%note title=Note%}
Available in the premium edition only
{%endnote%}

## Cloudify CLI: cfy commands
cfy commands that connect to the REST service (e.g. "deployments create") send username and password in a header on each
request. Setting these values is done once, via these environment variables:

 - CLOUDIFY_USERNAME
 - CLOUDIFY_PASSWORD

### SSL CLI configuration

#### Connect with a manager secured by SSL:
  - After bootstrap, every request to the secured manager will be on port 443, using the 'https' protocol.
  - The `use` command requires specifing the port option to be 443 
      <br>e.g. 
      {% highlight bash %}
        'use -t <manager-ip-address> --port 443'
      {% endhighlight %}

#### Manager's certificate verification:
By default, the manager's certificate will be verified.<br>
There are two environment variables that can be set:
  
  - `CLOUDIFY_SSL_TRUST_ALL` - set to any non empty value to avoid certificate verification.
  - `CLOUDIFY_SSL_CERT_PATH` - set the path to a copy of the manager's certificate in case verification is wanted (trust all is not set) and the manager's certificate is a self-signed certificate. 


{%note title=Note%}
This client only supports authentication with username-password
{%endnote%}

## Other REST clients
other REST clients (e.g. cURL) must explicitly add credentials to each request.<br>
For example:

 - Get the server status, authenticate with username and password:<br>
curl -u 'MY_USERNAME':'MY_PASSWORD' MANAGER_IP/status
 - Get a token, authenticate with username and password:<br>
curl -u 'MY_USERNAME':'MY_PASSWORD' MANAGER_IP/tokens
 - Get all the blueprints, authenticate with a token:<br>
curl -H 'Authentication-Token:MY_TOKEN' MANAGER_IP/blueprints


# Behind the Scenes / Advanced

## Secured Request Flow

![request-flow]({{ site.baseurl }}/guide/images3/guide/request_flow.png)

## Internal communication between the Cloudify manager and other Cloudify components

Currently, communication between the Cloudify agents and the Cloudify manager does not go through authentication - instead, REST calls from the agents to the manager are done to port 8101, which has the same general behavior as port 80, yet the REST service lets requests made to this port through without having them go through any of the security mechanisms.

The usage of this port, however, is restricted to components on the same subnet as the Cloudify manager alone. This is done using specific security group rules, which are set up during bootstrap (for example, see [this rule in the Openstack manager blueprint](https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/master/openstack/openstack-manager-blueprint.yaml#L206)). It is therefore impossible to bypass the security mechanisms from outside the manager's internal network by making REST calls directly to the 8101 port.

In future versions, all communications from and to the Cloudify manager will utilize the security mechanisms, including communication with any of Cloudify's internal components, at which time, the bypass port 8101 will be removed.


## Advanced configuration (logs, token timeout, password hashing, nginx)


# Using your own userstore and authentication providers

## Packaging, Configuring and Installing Custom Implementations

In order to use custom implementations of userstores, authentication providers and token generators; the implementations themselves should be installed on the manager.

To do this, the manager blueprint should be updated as follows.

Say you write a custom authentication provider. The code itself should be structured in a similar way to how [operations/workflows](plugins-authoring.html) plugins are structured, that is to say, it should be structured as a valid python package.

You specify the package location under the `plugins` section in the `cloudify` property of the `manager` node in the manager blueprint like this:
{% highlight yaml %}
node_templates:
  ...
  manager:
    ...
    properties:
      ...
      cloudify:
        plugins:
          my_authentication_provider:

            # see description below
            source: my-extensions/simple-authentication-provider

            # see description below
            install_args: '--pre'

          my_userstore:

            # see description below
            source: https://github.com/my-org/my-auth-provider/archive/master.zip

{% endhighlight %}


### Configuration
The `plugins` section is a dict that contains all plugins that should be installed.

The keys of this dict are arbitrary names. In the previous example we used `my_authentication_provider` and `my_userstore` as the names.

* `source` Can be any of the following:
  * A path to the package directory (a valid python package) relative to the [main manager blueprint file](reference-terminology.html#main-blueprint-file) directory (e.g. `my-extensions/simple-authentication-provider`)
  * A URL to the package archive (e.g. `https://github.com/my-org/my-auth-provider/archive/master.zip`)
* `install_args` You may pass additional arguments to the `pip install` command used to install your plugin.


{%note title=Note%}
When the term *plugin* is used in this section, it should not be confused with operation and workflow plugins (except when explicitly mentioned otherwise).

When we use this term here, we simply mean: custom code that gets installed in the manager environment. In other words, plugins here cannot be used as operations and workflows plugins.
{%endnote%}


## Examples

### LDAP UserStore Example:
  An example for a userstore class - [LDAPUserStore](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/examples/ldap_userstore.py).<br>
  This class inherits from [AbstractUserstore](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/abstract_userstore.py) and implements the `get_user` method as required. 

  The properties to initialize this class should be specified in the manager blueprint as described earlier in [Configuring a Userstore](#configuring-a-userstore), e.g.
  {% highlight yaml %}
  userstore_driver:
    implementation: flask_securest.userstores.examples.ldap_userstore:LDAPUserStore
    properties:
      admin_dn: cn=admin,dc=cloudify,dc=org
      admin_password: password
      directory_url: ldap://localhost:389
      root_dn: dc=cloudify,dc=org
      identifying_attribute: uid
      username_attribute: uid
      user_password_attribute: userPassword
      user_email_attribute: mail
      is_active_attribute: is_active
  {% endhighlight %}
  The above properties are specific to this example implementation.

  In order to use this custom userstore, the implementation of the LDAPUserStore class should be installed on the manager as describe in [Packaging, Configuring and Installing Custom Implementations](#packaging-configuring-and-installing-custom-implementations), e.g.
  {% highlight yaml %}
  node_templates:
    ...
    manager:
      ...
      properties:
        ...
        cloudify:
          plugins:
            ldap_userstore:
              source: userstores
  {% endhighlight %}
  where userstores is the path to the userstores directory, relative to the manager blueprint's directory, for example:
  
  {% highlight yaml %}
  
  my_app:
    userstores:
      ldap_userstores:
        __init__.py
        simple_ldap_userstore.py
      README.md
      setup.py
    my-manager-blueprint.yaml
  
  {% endhighlight %}
  
  {%note title=Note%}
  This ldap userstore example uses the [Python LDAP](http://www.python-ldap.org/doc/html/ldap.html#module-ldap) and the [Flask-SecuREST](https://github.com/cloudify-cosmo/flask-securest) modules.<br>
  To install python-ldap successfully, the following development libraries are needed (package names taken from ubuntu environment):
    {%highlight bash%}
    sudo apt-get install -y python-dev libldap2-dev libsasl2-dev libssl-dev
    {%endhighlight%}

  In order for the plugin installation to be successfull, these packages must be installed.<br>
  Unfortunately, currently there is no convenient way for specifying system dependencies as plugin requirements.<br>
  This is a known issue and is intended to be solved in Cloudify 3.3.<br>
  To work around it, one option is to supply a custom cloudify manager docker image with the above packages installed (see [Generate a custom Cloudify manager image](https://github.com/cloudify-cosmo/cloudify-packager/blob/master/README.md#generate-a-custom-cloudify-manager-image))<br>
  Another work-around is to add the installation command to the setup.py file, for example:
  
{%highlight yaml%}
import os
from setuptools import setup

os.system('sudo apt-get install -y libldap2-dev libsasl2-dev')

setup(
  name='userstores',
  version='0.1',
  url='https://github.com/cloudify-cosmo/flask-securest/userstores/examples',
  license='LICENSE',
  author='cosmo-admin',
  author_email='cosmo-admin@gigaspaces.com',
  description='userstore examples',
  packages=[
    'ldap_userstores'
  ],
  install_requires=[
  'python-ldap>=2.4.19',
    'Flask-SecuREST>=0.6'
  ]
)
{%endhighlight%}

{%endnote%}


### Password Based Authentication Provider Example:
  An example for authentication provider - [PasswordAuthenticator](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authentication_providers/password.py)
  This class implements an authentication provider based on password authentication. 
  The `authenticate` method compares the password given from the user store (using the `get_user()` method) with the one recieved from the user (on the request).

  The properties to initialize this class should be specified in the manager blueprint as described earlier in [Configuring Authentication Providers](#configuring-authentication-providers).<br>


