---
layout: blogpost
title: Cloud integration and DevOps automation experience shared
image: dotan.jpg
author: Dotan Horovits
tags: 
 - Cloudify
 - DevOps
 - Cloud
 - PaaS 
---

<div class="post-117 post type-post status-publish format-standard hentry category-cloud category-devops category-iaas category-paas tag-apache tag-cloudify tag-ec2 tag-jclouds tag-jersey tag-jsch tag-openstack tag-rackspace tag-rest tag-vfs" id="post-117">					
											
					<h1 class="entry-title">Cloud integration and DevOps automation experience&nbsp;shared</h1>

					<div class="entry entry-content">
						<p>The Cloud carries the message of automation to system architecture. The ability to spin up VMs on demand and take them down when no longer needed as per the applications' real-time requirements and metrics is the key for making the system truely elastic, scalable and self-healing. When using external IaaS providers, this also saves the hassle of managing the IT aspects of the on-demand infrastructure.</p>
<p>But with potential of automation comes the challenge of integrating with the cloud provider (or providers) and automating the management of the VMs, dealing with DevOps aspects such as accessing the VM, transferring contents to it, performing installations, running and stopping processes on it, coordinating between the services, etc. On this post I'd like to share with you some of my experience integrating with IaaS cloud providers, as part of my work with customers using the open source <a href="/" title="cloudifysource.org">Cloudify</a> PaaS product. Cloudify provides out-of-the-box integration with many popular cloud providers, such as&nbsp;<a href="http://aws.amazon.com/" oncontextmenu="mugicRightClick(this);" onclick="return mugicPopWin(this,event);">Amazon EC2</a>&nbsp;and&nbsp;<a href="http://www.rackspace.com/">The Rackspace Cloud</a>,&nbsp;as well as integration with the popular&nbsp;<a href="http://www.jclouds.org/">jclouds</a>&nbsp;framework and <a href="http://openstack.org/" title="openstack.org">OpenStack</a>&nbsp;open&nbsp;standard. But when encountering an emerging cloud provider or standard, you just need to pull up your sleeves and write your own integration. As a best practice, I use Java for the cloud integration and try to leverage on well-proven and community-backed open source projects wherever possible. Let's see how I did it.</p>
<p>First we need to integrate with the IaaS API to enable automation of resource allocation and deallocation.&nbsp;The main integration point is called a <a href="/guide/2.1/clouddrivers/cloud_driver.html">Cloud Driver</a>, which is basically a Java class that adheres to a <a href="/guide/2.1/clouddrivers/developing_custom_clouddriver.html" title="Developing a custom cloud driver">simple API</a> for accessing the cloud for resources. Various clouds expose various APIs for accessing them. Programmatic access is native and easy to implement from the Cloud Driver code. REST API is also quite popular, in which cases I found the <a href="http://jersey.java.net/" title="Apache Jersey">Apache Jersey</a> client open source library quite convenient for implementing a <a href="http://www.mkyong.com/webservices/jax-rs/restful-java-client-with-jersey-client/">RESTful client</a>. Jersey is based on <a href="http://docs.oracle.com/javaee/6/tutorial/doc/giepu.html" title="Building RESTful Web Services with JAX-RS">JAX-RS</a> Java community standard, and offers easy handling of various flavors of calls, cookie handling, policy governance, etc.&nbsp;Cloudify offers a convenient&nbsp;<a href="https://gist.github.com/1770098" title="DSL example">Groovy-based DSL</a>&nbsp;that enables you to configure the cloud provider's parameters and properties in a declarative and easy-to-read manner, and takes care of the wiring for you. When writing your custom cloud driver you should make sure to sample and use the values from the Groovy (you can add custom properties as needed), so after the cloud driver is ready for a given cloud provider, you can use it in any deployment by simply setting the configuration.&nbsp;I used the source code of the cloud drivers on CloudifySource public&nbsp;<a href="https://github.com/CloudifySource/cloudify">GitHub repository</a>, as a great source of reference for writing my cloud driver.</p>
<p>The next DevOps aspect of the integration is accessing the VMs and managing them. Linux/Unix VMs are accessed via SSH for executing scripts, and uses SFTP for file transfer. For generic file transfer layer there's the&nbsp;<a href="http://commons.apache.org/vfs/" title="Apache VFS">Apache Commons VFS2</a> (Virtual File System), which offers a&nbsp;uniform view of the files from various different sources (local FS, remote over HTTP, etc.). For remote command execution over SSH there's <a href="http://www.jcraft.com/jsch/">JCraft's JSch</a> library, providing a Java implementation of SSH2. Authentication also needs to be addressed with the above. Luckily, many of these things that we used to do manually as part of DevOps integration are new being taken care of by Cloudify. Indeed, there's still much integration headache with ports not opened, passwords incorrect etc. which takes up most of the time, and more logs are definitely required in Cloudify to figure things out and troubleshoot. What I did is I simply forked the <a href="https://github.com/CloudifySource/cloudify">open source project from GitHub</a> and debugged right through the code, which has the side benefit of &nbsp;fixing and improving the project on the fly and contributing back to the community. I should mention that although the environments I integrated with where Linux-based, Cloudify also provides support for Windows-based systems (based on WinRM, CIFS and PowerShell).</p>
<p>One of the coolest things added in Cloudify 2.1 that was <a href="/2012/05/01/whats_new_in_cloudify_2_1.html">launched last week</a> was the <a href="/guide/2.1/bootstrapping/bootstrapping_byon.html">BYON (Bring Your Own Node) driver</a>, which allows you to take your&nbsp;existing bare-metal servers and use them as managed resources for deployment by Cloudify, as if they were on-demand resources. This provides a neat answer to the <a href="http://www.infoworld.com/d/cloud-computing/going-native-the-move-bare-metal-cloud-services-192507" title="InfoWorld: Going native: The move to bare-metal cloud services">growing demand for bare-metal cloud services</a>. I'm still waiting for the opportunity to give this one a wet run with a customer in the field...</p>
<p>All in all, it turned out to be a straight-forward task to integrate with a new cloud provider. Just make sure you have a stable environment and a test code on how to consume the APIs, and use the existing examples as reference, and you're good to go.</p>